using System;
using System.Collections;
using Petera3d;
using Unity.Mathematics;
using UnityEngine;
using Random = UnityEngine.Random;

public class BoundingSphereFromDirectionOfMaximumSpread : MonoBehaviour
{
    private Sphere _sphere;
    [SerializeField] private Point[] _points;
    private Point _minPoint, _maxPoint;
    private Vector3 _eigenDirection;
    
    //Random range of autogenerated points
    [Space(10)]
    [Header("X Axis Random Range")] [SerializeField]
    [Range(-100,0)]
    private float _xAxisFrom = -10;
    [Range(0,100)]
    [SerializeField]private float _xAxisTo = 10;
    [Space(10)]
    
    [Space(10)]
    [Header("Y Axis Random Range")] [SerializeField]
    [Range(-100,0)]
    private float _yAxisFrom = -30;
    [Range(0,100)]
   [SerializeField] private float _yAxisTo = 30;
    [Space(10)]
    
    [Space(10)]
    [Header("Z Axis Random Range")] [SerializeField]
    [Range(-100,0)]
    private float _zAxisFrom = -5;
    [Range(0,100)]
    [SerializeField] private float _zAxisTo = 5;
    [Space(30)]
    
  [Tooltip("AMount of points ")]
    public int PointsAmount;
    
    struct Sphere
    {
        public float Radius;
        public Point Center;
    }


    #region Functions

    //Encompass point p in sphere if needed.
    //Some points remains slightly out of bounding sphere.
    //This function iterates through all points and check if point is out of the sphere bounds, then recompute sphere center and radius
    //in order to encompass out of bounds point

    void UpdateSphereToFitOutOfSherePoints(Point p)
    {
        Point d = p - _sphere.Center;
        float dist2 = Vector3.Dot(d.ToVector3(), d.ToVector3()); //Use squared distance for comparison (performance)
        if (dist2 > _sphere.Radius * _sphere.Radius)
        {
            float dist = Mathf.Sqrt(dist2);
            float newRadius = (_sphere.Radius + dist) * 0.5f;
            float k = (newRadius - _sphere.Radius) / dist; //Compute the coefficient for new Sphere center. Center have to make position displacement in order to encompass new point.
            _sphere.Radius = newRadius;
            _sphere.Center += d * k;
        }
    }

    //Get min and max positions of extreme points in array along eigenvector direction.
    void GetExtremePointsAlongDirection(Vector3 direction, Point[] points, out Point minPoint, out Point maxPoint)
    {
        float minProj = float.MaxValue;
        float maxProj = float.MinValue;
        int iMax = 0, iMin = 0;
        for (int i = 0; i < points.Length; i++)
        {
            float proj = Vector3.Dot(points[i].ToVector3(), direction);
            if (proj > maxProj)
            {
                maxProj = proj;
                iMax = i;
            }

            if (proj < minProj)
            {
                minProj = proj;
                iMin = i;
            }
        }

        minPoint = points[iMin];
        maxPoint = points[iMax];
    }

    void BoundingSphereFromPointsSpread(Point[] points)
    {
        Matrix3x3 covarianceMatrix = Probability.CovarianceMatrix(points);
        Jacobi jacobi = new Jacobi(covarianceMatrix);
        jacobi.JacobiRotation(out Matrix3x3 eigenVectors, out Matrix3x3 eigenValues);

        //Find the largest absolute eigenValue (largest spread)
        float largestEnValue = math.abs(eigenValues[0, 0]);
        int eigenVectorsColumn = 0;
        if (math.abs(eigenValues[1, 1]) > largestEnValue)
        {
            eigenVectorsColumn = 1;
            largestEnValue = math.abs(eigenValues[1, 1]);
        }

        if (math.abs(eigenValues[2, 2]) > largestEnValue)
        {
            eigenVectorsColumn = 2;
        }

        //Directional verctor showing the largest spread direction
        _eigenDirection = new Vector3(eigenVectors[0, eigenVectorsColumn], eigenVectors[1, eigenVectorsColumn],
            eigenVectors[2, eigenVectorsColumn]);
        GetExtremePointsAlongDirection(_eigenDirection, points, out _minPoint, out _maxPoint);
        Vector3 dir = _maxPoint.ToVector3() - _minPoint.ToVector3();
        _sphere.Radius = dir.magnitude * 0.5f;
        _sphere.Center = (_maxPoint + _minPoint) * 0.5f;
    }

    //Visualise with delay how sphere resize to out of bounds points
    IEnumerator testIe(Point[] points)
    {
        for (int i = 0; i < points.Length; i++)
        {
            UpdateSphereToFitOutOfSherePoints(points[i]);
            yield return new WaitForSeconds(0.8f);
        }
    }

    void RitterEigenSphere()
    {
        BoundingSphereFromPointsSpread(_points);
        //After computing bounding sphere make sure that all points in array are encompassed by the sphere. 
        for (int i = 0; i < _points.Length; i++)
        {
            UpdateSphereToFitOutOfSherePoints(_points[i]);
        }
    }

    #endregion

    #region EditorFunctions

    public void GenerateRandomPoints()
    {
        if (PointsAmount == 0) throw new ArgumentException("Points amount is zero."); 
        Reset(false);
        for (int i = 0; i < _points.Length; i++)
        {
            float x = Random.Range(_xAxisFrom, _xAxisTo);
            float y = Random.Range(_yAxisFrom, _yAxisTo);
            float z = Random.Range(_zAxisFrom, _zAxisTo);
            _points[i] = new Point(x, y, z);
        }
    }

    public void CreateBoundShere()
    {
        RitterEigenSphere();
    }

    public void Reset(bool all = true)
    {
        if (all) PointsAmount = 0;
        _minPoint = new Point(0, 0, 0);
        _maxPoint = new Point(0, 0, 0);
        _points = new Point[PointsAmount];
        _sphere.Center = new Point(0, 0, 0);
        _sphere.Radius = 0;
    }

    #endregion


    private void OnDrawGizmosSelected()
    {
        if (PointsAmount == 0) return;
        Gizmos.color = Color.yellow;
        for (int i = 0; i < _points.Length; i++)
        {
            Gizmos.DrawSphere(_points[i].ToVector3(), 1.3f);
        }

        Gizmos.color = Color.cyan;

        Gizmos.DrawSphere(_minPoint.ToVector3(), 1.3f);
        Gizmos.DrawSphere(_maxPoint.ToVector3(), 1.3f);

        Gizmos.DrawWireSphere(_sphere.Center.ToVector3(), _sphere.Radius);
        Gizmos.DrawRay(_sphere.Center.ToVector3(), _eigenDirection * 20);
    }
}
